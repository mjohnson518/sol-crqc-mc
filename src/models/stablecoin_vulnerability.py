"""
Stablecoin vulnerability model for quantum attacks on Solana.

Based on Project Eleven's analysis of stablecoin admin key vulnerabilities,
this module models the unique risks posed to USD-pegged assets on Solana.
Reference: https://blog.projecteleven.com/posts/vulnerabilities-of-stablecoins-to-quantum-attacks
"""

import numpy as np
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Tuple
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class StablecoinType(Enum):
    """Types of stablecoins on Solana."""
    CENTRALIZED = "centralized"      # USDC, USDT - admin key controlled
    ALGORITHMIC = "algorithmic"      # Protocol-governed
    WRAPPED = "wrapped"              # Bridge-based assets


@dataclass
class StablecoinAsset:
    """Represents a stablecoin on Solana."""
    name: str
    symbol: str
    type: StablecoinType
    tvl_on_solana: float            # Total value locked on Solana
    admin_keys: int                  # Number of admin keys
    multisig_threshold: int          # Keys needed for admin actions
    freeze_capable: bool             # Can freeze user accounts
    mint_capable: bool               # Can mint new tokens
    upgrade_capable: bool            # Can upgrade contract logic
    daily_volume: float              # Average daily trading volume
    defi_integration_score: float   # 0-1: How integrated in DeFi
    
    def quantum_compromise_time(self, qubits: int) -> float:
        """Calculate time to compromise admin keys with quantum computer.
        
        Based on Ed25519 cryptanalysis from Roetteler et al. (2017).
        """
        if qubits < 2330:
            return float('inf')  # Not enough qubits
        
        # Base time: 6-24 hours per key
        base_hours_per_key = np.random.uniform(6, 24)
        
        # Need to break threshold number of keys
        keys_to_break = min(self.multisig_threshold, self.admin_keys)
        
        # Can parallelize if have multiple quantum computers
        parallelization_factor = min(keys_to_break, max(1, qubits // 2330))
        
        total_hours = (keys_to_break * base_hours_per_key) / parallelization_factor
        
        return total_hours
    
    def calculate_cascade_factor(self) -> float:
        """Calculate how failure cascades through DeFi ecosystem.
        
        USDC has highest cascade due to being primary collateral.
        """
        # USDC is primary collateral across DeFi
        if self.symbol == "USDC":
            collateral_multiplier = 3.0  # Triple impact
        elif self.symbol == "USDT":
            collateral_multiplier = 2.0  # Double impact
        else:
            collateral_multiplier = 1.2  # Modest cascade
        
        # Integration amplifies cascade (but not too much)
        integration_bonus = 0.5 * self.defi_integration_score
        
        return collateral_multiplier + integration_bonus


# Solana stablecoins data (December 2024 estimates)
SOLANA_STABLECOINS = {
    "USDC": StablecoinAsset(
        name="USD Coin",
        symbol="USDC",
        type=StablecoinType.CENTRALIZED,
        tvl_on_solana=5_000_000_000,  # $5B
        admin_keys=3,
        multisig_threshold=2,
        freeze_capable=True,
        mint_capable=True,
        upgrade_capable=True,
        daily_volume=800_000_000,
        defi_integration_score=0.95  # Primary collateral
    ),
    "USDT": StablecoinAsset(
        name="Tether",
        symbol="USDT",
        type=StablecoinType.CENTRALIZED,
        tvl_on_solana=3_000_000_000,  # $3B
        admin_keys=2,
        multisig_threshold=1,
        freeze_capable=True,
        mint_capable=True,
        upgrade_capable=True,
        daily_volume=600_000_000,
        defi_integration_score=0.75
    ),
    "PYUSD": StablecoinAsset(
        name="PayPal USD",
        symbol="PYUSD",
        type=StablecoinType.CENTRALIZED,
        tvl_on_solana=500_000_000,  # $500M
        admin_keys=2,
        multisig_threshold=2,
        freeze_capable=True,
        mint_capable=True,
        upgrade_capable=False,
        daily_volume=50_000_000,
        defi_integration_score=0.3
    ),
    "DAI": StablecoinAsset(
        name="Dai Stablecoin",
        symbol="DAI",
        type=StablecoinType.WRAPPED,  # Bridged from Ethereum
        tvl_on_solana=200_000_000,  # $200M
        admin_keys=1,  # Bridge admin
        multisig_threshold=1,
        freeze_capable=False,
        mint_capable=True,  # Bridge can mint
        upgrade_capable=True,
        daily_volume=20_000_000,
        defi_integration_score=0.5
    ),
    "UXD": StablecoinAsset(
        name="UXD Stablecoin",
        symbol="UXD",
        type=StablecoinType.ALGORITHMIC,
        tvl_on_solana=50_000_000,  # $50M
        admin_keys=3,
        multisig_threshold=2,
        freeze_capable=False,
        mint_capable=True,
        upgrade_capable=True,
        daily_volume=5_000_000,
        defi_integration_score=0.2
    )
}


@dataclass
class StablecoinAttackScenario:
    """Models a quantum attack on stablecoin admin keys."""
    target_stablecoin: str
    compromise_time_hours: float
    immediate_impact: float         # Direct loss from minting/theft
    depeg_probability: float        # Chance of losing peg
    depeg_severity: float           # How far from $1.00
    cascade_impact: float           # Total ecosystem impact
    confidence_impact: float        # Market confidence loss multiplier
    attribution_difficulty: float   # 0-1: How hard to attribute attack
    
    def total_economic_impact(self) -> float:
        """Calculate total economic impact including cascades."""
        direct = self.immediate_impact
        cascade = self.cascade_impact
        confidence = (direct + cascade) * self.confidence_impact
        return direct + cascade + confidence
    
    def is_systemic_threat(self) -> bool:
        """Determine if attack poses systemic risk to Solana."""
        return (self.total_economic_impact() > 10_000_000_000 or  # $10B+
                self.depeg_probability > 0.8 or
                self.cascade_impact > self.immediate_impact * 5)


class StablecoinVulnerabilityModel:
    """Model stablecoin-specific quantum vulnerabilities on Solana."""
    
    def __init__(self):
        self.stablecoins = SOLANA_STABLECOINS
        self.total_stablecoin_tvl = sum(
            s.tvl_on_solana for s in self.stablecoins.values()
        )
    
    def assess_vulnerability(
        self,
        quantum_capability: int,  # Logical qubits available
        attacker_motivation: str = "profit"  # profit, destabilize, demonstrate
    ) -> Dict[str, StablecoinAttackScenario]:
        """Assess vulnerability of each stablecoin to quantum attack."""
        scenarios = {}
        
        for symbol, stablecoin in self.stablecoins.items():
            # Calculate compromise time
            compromise_time = stablecoin.quantum_compromise_time(quantum_capability)
            
            if compromise_time == float('inf'):
                continue  # Not vulnerable yet
            
            # Immediate impact from minting attack
            if stablecoin.mint_capable:
                # Attacker could mint massive amounts
                if attacker_motivation == "destabilize":
                    # Nation-state: mint to destabilize USD confidence
                    mint_amount = stablecoin.tvl_on_solana * 2.0  # Double supply
                else:
                    # Criminal: mint for profit but not too obvious
                    mint_amount = stablecoin.tvl_on_solana * 0.5  # 50% increase
                
                immediate_impact = mint_amount
            else:
                immediate_impact = stablecoin.tvl_on_solana * 0.3  # Theft only
            
            # Depeg probability and severity
            supply_shock = mint_amount / stablecoin.tvl_on_solana if stablecoin.mint_capable else 0
            depeg_probability = min(0.99, supply_shock * 0.3 + 0.1)
            depeg_severity = min(0.99, supply_shock * 0.1)  # How far from $1
            
            # Cascade effects
            cascade_factor = stablecoin.calculate_cascade_factor()
            cascade_impact = immediate_impact * cascade_factor
            
            # Confidence impact (higher for systemic stablecoins)
            if symbol == "USDC":
                confidence_multiplier = 3.0  # Major confidence crisis
            elif symbol == "USDT":
                confidence_multiplier = 2.5
            else:
                confidence_multiplier = 1.5
            
            # Attribution difficulty
            if attacker_motivation == "destabilize":
                # Nation-states better at hiding
                attribution_difficulty = 0.9
            else:
                attribution_difficulty = 0.4
            
            scenarios[symbol] = StablecoinAttackScenario(
                target_stablecoin=symbol,
                compromise_time_hours=compromise_time,
                immediate_impact=immediate_impact,
                depeg_probability=depeg_probability,
                depeg_severity=depeg_severity,
                cascade_impact=cascade_impact,
                confidence_impact=confidence_multiplier,
                attribution_difficulty=attribution_difficulty
            )
        
        return scenarios
    
    def calculate_systemic_risk(
        self,
        scenarios: Dict[str, StablecoinAttackScenario]
    ) -> Dict[str, float]:
        """Calculate systemic risk metrics from attack scenarios."""
        if not scenarios:
            return {
                "total_value_at_risk": 0,
                "systemic_cascade_multiplier": 0,
                "confidence_crisis_probability": 0,
                "max_depeg_severity": 0
            }
        
        # Total value at risk
        total_at_risk = sum(s.total_economic_impact() for s in scenarios.values())
        
        # Systemic cascade (USDC failure triggers everything)
        if "USDC" in scenarios:
            usdc_cascade = scenarios["USDC"].cascade_impact
            systemic_multiplier = usdc_cascade / scenarios["USDC"].immediate_impact
        else:
            systemic_multiplier = 1.0
        
        # Confidence crisis probability (any major stablecoin failure)
        major_stables = ["USDC", "USDT"]
        confidence_crisis_prob = max(
            scenarios.get(s, StablecoinAttackScenario(
                target_stablecoin=s, compromise_time_hours=float('inf'),
                immediate_impact=0, depeg_probability=0, depeg_severity=0,
                cascade_impact=0, confidence_impact=0, attribution_difficulty=0
            )).depeg_probability
            for s in major_stables
        )
        
        # Maximum depeg severity
        max_depeg = max(s.depeg_severity for s in scenarios.values())
        
        return {
            "total_value_at_risk": total_at_risk,
            "systemic_cascade_multiplier": systemic_multiplier,
            "confidence_crisis_probability": confidence_crisis_prob,
            "max_depeg_severity": max_depeg,
            "attribution_difficulty": np.mean([s.attribution_difficulty for s in scenarios.values()])
        }
    
    def simulate_coordinated_attack(
        self,
        quantum_capability: int,
        targets: List[str],
        attacker_motivation: str = "destabilize"
    ) -> Dict[str, any]:
        """Simulate coordinated attack on multiple stablecoins.
        
        Nation-states might target multiple stablecoins simultaneously
        for maximum destabilization effect.
        """
        individual_scenarios = self.assess_vulnerability(
            quantum_capability, attacker_motivation
        )
        
        coordinated_impact = 0
        total_time = 0
        
        for target in targets:
            if target in individual_scenarios:
                scenario = individual_scenarios[target]
                coordinated_impact += scenario.total_economic_impact()
                total_time = max(total_time, scenario.compromise_time_hours)
        
        # Coordinated attacks have multiplier effect on confidence
        if len(targets) > 1:
            coordination_multiplier = 1.5 * len(targets)
            coordinated_impact *= coordination_multiplier
        
        return {
            "targets": targets,
            "total_impact": coordinated_impact,
            "attack_duration_hours": total_time,
            "systemic_collapse_probability": min(0.99, coordinated_impact / self.total_stablecoin_tvl),
            "recovery_time_months": len(targets) * 6  # Longer with multiple failures
        }


# Example usage
if __name__ == "__main__":
    model = StablecoinVulnerabilityModel()
    
    # Test with 3000 logical qubits (quantum capability)
    scenarios = model.assess_vulnerability(3000, "destabilize")
    
    print("Stablecoin Vulnerability Assessment:")
    print("=" * 50)
    
    for symbol, scenario in scenarios.items():
        print(f"\n{symbol}:")
        print(f"  Compromise Time: {scenario.compromise_time_hours:.1f} hours")
        print(f"  Immediate Impact: ${scenario.immediate_impact/1e9:.2f}B")
        print(f"  Cascade Impact: ${scenario.cascade_impact/1e9:.2f}B")
        print(f"  Total Impact: ${scenario.total_economic_impact()/1e9:.2f}B")
        print(f"  Depeg Probability: {scenario.depeg_probability:.1%}")
        print(f"  Systemic Threat: {scenario.is_systemic_threat()}")
    
    # Calculate systemic risk
    risk_metrics = model.calculate_systemic_risk(scenarios)
    print(f"\nSystemic Risk Metrics:")
    print(f"  Total Value at Risk: ${risk_metrics['total_value_at_risk']/1e9:.1f}B")
    print(f"  Cascade Multiplier: {risk_metrics['systemic_cascade_multiplier']:.1f}x")
    print(f"  Confidence Crisis Probability: {risk_metrics['confidence_crisis_probability']:.1%}")
    
    # Test coordinated attack
    coordinated = model.simulate_coordinated_attack(
        3000, ["USDC", "USDT"], "destabilize"
    )
    print(f"\nCoordinated Attack on USDC + USDT:")
    print(f"  Total Impact: ${coordinated['total_impact']/1e9:.1f}B")
    print(f"  Attack Duration: {coordinated['attack_duration_hours']:.1f} hours")
    print(f"  Systemic Collapse Probability: {coordinated['systemic_collapse_probability']:.1%}")
